<!--
 Copyright (C) 2024 Innovate for Vegas Foundation
 
 This file is part of doc-agile-for-volunteers.
 
 doc-agile-for-volunteers is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 doc-agile-for-volunteers is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with doc-agile-for-volunteers.  If not, see <https://www.gnu.org/licenses/>.
-->

# Glossary of Terms for a Ubiquitous Language

Using terms in a consistent way is helpful to make understanding across an initiative easier, more likely, and less potentially-troublesome that allowing jargon or casual terminology to divide efforts.

Indeed, from *Design Driven Development* by Eric Evans (2003), Ubiquitous Language is described as an essential component to productive collaboration, conveyed in two quotes taken both from **Page 41** of that work:

> To create a supple, knowledge-rich design calls for a versatile, shared team language, and a lively
> experimentation with language that seldom happens on software projects.

and

> A project faces serious problems when its language is fractured. Domain experts use their jargon
> while technical team members have their own language tuned for discussing the domain in terms of design.

Ubiquitous Language is frequently references and described, these are links some links from the old days (though these considerations apply today, and tomorrow):

- [Martin Fowler on Ubiquitous Language](https://martinfowler.com/bliki/UbiquitousLanguage.html)
- [CarbonFive blog on Ubiquitous Language](https://blog.carbonfive.com/ubiquitous-language-the-joy-of-naming/)

While the *DDD* book and references above are born of the Software Development process and efforts to improve it, in the context of Agile for Volunteers we can apply this notion to Domain Experts and Technical Experts across Coding, Media Creation, Language Translation, User Interface Design, Marketing, Quality Assurance, and so on, since anyone taking on any of these roles may well be a Domain Expert, or a Technical Expert, or both, with familiarity with their particular jargon, their Lingua Franca of their domain.

If we are all speaking the same language, if we are all on the same page, we can spend time on collaboration rather than stumbling over communication…

These below are useful in the context of a project making use of the Agile for Volunteers principles and methodologies, and will ideally fit with a particular Ubiquitous Language which applies to a particular Initiative focused on Education, Social Information Sharing, Community Elevation, and the list goes on.

## Terms

These are the terms we will use in the context of Agile for Volunteers (taken most often from The Agile Manifesto and related works, or adapted for our non-software-development application here). These terms are always subject to tuning for clarity, though their fundamental meanings should not evolve drastically.

### Planning

In the Agile for Volunteers, Whole Team approach, *Planning* a project is a collaborative and ongoing discussion that will ideally bring about a deliverable or deliverables that work for the intended customer(s). The entire process is always intended to be adaptive so that better outcomes remain the goal(s).

### Implementation

Whether a specification or an iterative and adaptive plan, the *Implementation* is the realization of intent, literally the conversion of *Planning* to Action.

### Abstract

This is a common Software Development term, but across any endeavor the notion of employing *Abstract* ideas defers decisions until later, until more information is known, until more customer feedback is available, and so on. Maintaining an abstraction for as long as possible will defer commitments to design, placement, requirements, dependencies, or various other similar considerations, until as late as is convenient.

### Concrete

This is a common Software Development term, but across any endeavor the notion of *Concrete* construction, deployment, implementation, and so on is the commitment to a location, methodology, architecture, and so on. Once a component is made concrete, it is usually more difficult to change and may have implications across other component projects and the individuals endeavoring to complete those projects.

### Whole Team

This is a term used commonly in Agile and Agile-like methodologies, an indication that the team working on an initiative or any of its component projects, is made up of contributors to these, regardless of their title, area(s) of expertise or experience, or specific interest areas. All voices should be heard, all opinions considered, all ideas pondered. When possible. the *Whole Team* could, and should, include customers or intended users of an Initiative and its component project parts.

### Persistent Team

This is a term not typically encountered in Agile and Agile-like methodologies, used to denote those who are committed to an Initiative and/or Component Project(s) across Iterations, maintaining the parts, meeting from time to time and discussing plans and tasks and keeping the Initiative in what we could call “Good Shape.” Members of this team will typically have administrative access using the tools at hand, for example the ability to add and remove Atomic Team members for an iteration, re-assign or otherwise triage and manage bug and defect issues, and so on. Members of a Persistent Team are, by implication, Owners or Maintainers or similar, depending on the context of the tools in use and the Whole Team in general.

### Atomic Team

This is a term not typically encountered in Agile and Agile-like methodologies, used in the context of Civic Volunteerism where individual contributors may not be consistently or reliably available to participate in Initiative *Iterations*. Individuals may be added or removed from *Atomic Teams* through the life of an *Initiative*, which does not automatically impact their attribution nor the value of their contributions to the *Initiative* through its development lifecycle(s).

### Stakeholder

This is a term used commonly in Agile and Agile-like methodologies, indicating an individual or group with a known or not-yet-known interest in the progress and outcome(s) of an Initiative. An internal *Stakeholder* may be participating actively in the pursuit of an Initiative or its Component Projects, while an External *Stakeholder* might not be aware of the Initiative, or may be distal and vaguely aware, but might later make use of the outcome(s) of the Initiative.

### Customer

This is a term used commonly in Agile and Agile-like methodologies, and appears specifically in the Agile Manifesto. A *Customer* is an Internal Stakeholder, involved actively or passively in the iterative development of an Initiative and its Component Projects so that the eventual outcome(s) meet expectations, address known needs (which may become known during ongoing discussion, *Planning*, and development via active communication and perhaps *Co-Creation*). A Customer or Customers are typically represented directly via *User Stories*.

### Co-Creation

This is a more modern term indicating that the intended *Customer* or likely Users of an Initiative and its Component Projects will be involved to varying degrees in the *Planning* and *Implementation* phases of an Initiative. There are different styles of *Co-Creation* with differing levels of involvement, especially where the Customer or other Users may have differing perspectives, different levels of awareness of the intricacies of an Initiative and its goals, not to mention different levels of expertise and time to commit. In other words, representatives of The Real World.

### Initiative

This is a term used sometimes in Agile methodologies, sometimes used synonymously with *Theme*. Here, we use *Initiative* to indicate the top of a *Component* hierarchy. An example Initiative might be to “Make a Toolbox.”

### Theme

This is a term used sometimes in Agile methodologies, sometimes used synonymously with or instead of *Initiative*. Here we use Theme to divide a general Initiative into specific related *Epics* to realize some level of functionality or similar. If the Initiative is to Make a Toolbox, Themes might be “Make a Hammer,” “Make a Screwdriver,” “Make a Paint Brush,” and so on.

### Epic

This is a term used often in Agile methodologies, usually related to a *Theme* to collect *User Stories* (and here, *Features*) into functionally-related groups that might be realized in a single or few *Iterations*. It is important that Epics are conceived and factored to be achievable so that a sense of progress is attainable. If the Initiative is to “Make a Toolbox” and a Theme is to “Make a Hammer,” then one Epic might group together Features and User Stories describing handle materials, metallurgy, tools needed to convert raw materials into component parts, and so on.

### Feature

This is a term used less often in Agile methodologies, here a *Feature* is a general description of some behavior, capability, interface, and so on. A *Feature* might describe integration of a *Concrete* specification, such as a protocol or data format which is not subject to variations based on user needs. If our *Epic* is focused on “Make a Hammer,” one Feature might be compliance with accepted safety standards or perhaps certain material properties that do not vary based on User or Use Case.

### User Story

This is a term used ubiquitously in Agile methodologies to capture and describe needs and wants of a particular type of User (*Customer*, *Stakeholder*, others) of a particular *Feature*. Traditionally the User Story is captured on a Card, discussed in Conversation, and detailed with a collection of Confirmation details to indicate that a particular User Story meets the User needs and wants. These are the Three C´s of User Stories and represent the most thoughtful and considered collaboration of *Whole Team* to make things that work.

### Overview

With regard to Initiative Planning, an *Overview* is a Component Project itself which holds GitHub Projects, Blue Sky documents, Planning Issues, External Bug reporting issues and discussion categories, and any other information and resources needed to manage and indicate progress as an Initiative and its Components are developed. While the Overview appears as a Component Project, it does not contain code or other Theme Components, in that regard the Overview is more a Meta Component.

### Component

A *Component* manifests as a GitHub Repository (or a git repository on GitHub), and is likely actual code or documentation or similar tracked within the repository, though a Component may exist externally (a physical object, a large binary data set such as a multi media project, etc), tracked as part of an Initiative as a Component Project. Tasks related to a specific Component are tracked as Issues within the Component Project Repository.

### Task

A *Task* is an Implementation step intended to turn an abstract Feature or User Story into a Concrete manifestation, whether in the form of software code, written word, visible image, tangible mechanical device, and so on.

### External Bug

When a problem is found by someone not involved with Initiative or Component Project development (Planning, Implementation, etc), they may wish to report an *External Bug*. Typically, such bug reports will be a description of a problem without technical insight into implementation detail. External Bugs are captured in the Overview and are presumed to be non-specific and in need of Triage and clarification for granular assignment. A bug is a generic report which will ideally be converted to one or more specific Defect reports.

### Defect

When a problem is found by someone involved with Initiative or Component Project development (a Stakeholder, Customer, Team Member, et al), they may wish to report the problem with specific, implementation-related detail assigned to the appropriate Component Project(s). A Defect should be more specific than a Bug and should provide informed context and problem detail based on familiarity and some cases direct and specific knowledge of an Initiative and/or its Components.

### Blue Sky

In the very beginning of the beginning of an Initiative, a *Blue Sky* description should conjure broad notions of intent and outcome without specific detail and without granular, factored planning elements. In some cases there may be references to relevant protocols or formats to provide context and starting points, but the goal of the Blue Sky step is to think big, describe problems, gaps, challenges, and goals in broad terms, and begin a conversation and ongoing discussion concerning eventual Implementation of potential solutions after appropriate and iterative Planning takes place.

### Discussion

In the context of Agile for Volunteers Initiatives making using of GitHub tools, a *Discussion* is a feature used to facilitate categorized and attributed interaction on a variety of topics or categories. Discussion in this context is usually asynchronous and may include interaction with those not specifically involved with Initiative effort (external interactions).

### Conversation

In the Agile context, *Conversation* is an important step in a Planning process to develop and improve User Story and Feature planning (as well as Epics and Themes). *Conversation* is one of the 3 C´s of *User Story* interaction. and is often best done in a real-time, virtual or in-person interaction captured during the ongoing Planning process.

### Iteration

This is a term used ubiquitously in Agile methodologies, synonymous with *Sprint* and used to indicate a specific, focused time interval during which a Team endeavors to complete selected *Tasks*. In the case of *Atomic Teams* int he Agile for Volunteers scheme, members of Atomic Teams are members during the *Iteration*, but may choose to leave the team otherwise, making the *Iteration* a bounding time interval along the Initiative development path.

### Specification

A typical interpretation of a *Specification* is a set of requirements states as Rules for a particular Project (or Initiative), given to a Team to Implement. In keeping with Agile methodoligies, a Specification may be included as part of the Implementation of an Initiative where some external requirements are stated in this form (communications protocols, file formats, syntax requirements, and so on), while the Initiative itself is Planned not a a Specification, but as a set of Possibilities always subject to Whole Team reflection, iteration, and improvement.

### Retrospective

Most project management schemes will include a Postmortem step at the end to capture elements of the project completed which may need improvement. In Agile methodologies and specifically in Agile for Volunteers context, frequent *Retrospective* interactions at the ends of *Iterations* and other milestones will enable iterative and granular adjustments to how Civic Volunteers make use of not only their own time, effort, and expertise, but the contributions of same from others on their Team(s) or otherwise.

### Visibility

Members of an *Atomic Team* and *Stakeholders* involved in any phase of *Initiative* development will ideally be communicative, making their inputs, obstacles, and progress *Visible* to others (this is a matter of information sharing, not physical presence or participation in a virtual meeting per se). Interacting in forums and using tools that make these interactions visible to others will help to prevent Civic Volunteers from needing to repeat similar efforts, spend valuable time seeking answers already found, and so on.

### Observability

A *Component* or some system element that is complicated any some way should be *Observable* so that complication can be analyzed to address bugs and defects or potential for same. An *Observable* system can be analyzed more easily if *Observability* is a part of design considerations from beginning to end.

## Component Project Types

An Initiative is made up of one or more Component Projects (at least the Overview project repository), either stored directly in or tracked by a Repository. By using a consistent naming scheme (with aligned labels across all repositories) it is easier to locate components and represent relationships within the Initiative.

Use of a naming convention for Component Projects as they manifest on a platform such as GitHub as Git Repositories will, as the number of Initiatives and Component Projects grows, help to identify intent and relationship of and between the various repositories and thus Component Projects.

The Component Project repository name prefix is indicated in parentheses, eg (cp-ov) is (Component Project - OverView).

### Overview (cp-ov)

The *Overview* contains *Planning* and *Blue Sky* and other information about an *Initiative*.

### Back End (cp-be)

The *Back End* is software intended to execute on a server, in the cloud, or most simply without an interactive user interface.

### Front End (cp-fe)

The *Front End* is software intended to execute near a user with an interactive user interface, most likely an interface to be used within a Web Browser. More generally, a *Front End* component is exposed outside interaction and must react and respond accordingly.

### Documentation (cp-doc)

The *Documentation* component should be localizable and represents instructions and other useful information for *Customers* and other Consumers of some or all of an *Initiative*.

### Database (cp-db)

The *Database* component includes Schema definitions, interfaces, stored procedure and stored function definitions, and everything else needed to build, migrate, and use a backing store, whether SQL or NoSQL or something else.

### API Spec (cp-api)

The *Application Programmers Interface* is a structured description of how an external software service or application can make use of an exposed service using API Calls. Use of OpenAPI is one generally expected approach to publishing an API.

### SPI Spec (cp-spi)

The *System Programmers Interface* is a structure description of how internal Components interact, share information and functionality, and generally interoperate as part of the larger *Initiative*. The SPI is often not intended to be used externally, as is the case with an *API*.

### Application (cp-app)

A standalone *Application* is a monolithic component designed to accomplish some functionality on its own without specific dependency on other Components beyond interaction with a public *API*. An internal tool might be viewed similarly to make use of an *SPI* for example. In general, an *App* is focused on accomplishing specific goals in a self-contained implementation.

### User Interface (cp-ui)

Modern *User Interface* tools such as Figma or, even better, Penpot, can be used to build various views and elements of a simple or complex User Experience, here we can capture the development of the User Interface specifically.

### Infrastructure as Code (cp-iac)

Orchestration of cloud and other complicated resources is typically implemented via *Infrastructure as Code* tools such as Terraform and Pulumi, such that infrastructure may be built and re-built repeatedly without mystery.

### Hardware (cp-hw)

A general *Hardware* Component Project, likely in a technology-related Initiative to be the design schematics and layout of a circuit board or something similar.

### Mechanical (cp-mech)

A physical system, a *Mechanical* design likely including Computer Aided Design (CAD) files or similar definitions and descriptions.

### Industrial Design (cp-id)

A physical system often analogous to the software *Front End* Component, *Industrial Design* might be a computer case, a hardware enclosure, a front panel with buttons and lights, or anything similar that may ideally connect form, fit, and function in an aesthetically pleasing way.

### Multi Media (cp-mm)

A *Multi Media* Component may include Video, Audio, Still images, or other such things assembled or associated for some overall presentation or interaction

### Visual Assets (cp-vis)

A *Visual Asset* is more likely images (logo, avatar, complicated illustrations, etc) than video

### Audio Assets (cp-aud)

An *Audio Asset* is unencumbered music, spoken word, or some other effects to be used as part of an Initiative

### Bill of Materials (cp-bom)

The physical and virtual, internally-developed and externally-sourced components that make up a Component Project or some or all of an over-arching Initiative. A Bill of Materials may indicate alternate sources, versions, and other details that make possible the creation and recreation of an Initiative or Component Project(s) at a selected point in time (A bom may vary over time but should be reproducible for specific releases)

### Data (cp-data)

There may be some specific *Data* or Datasets that are required for Implementation of a particular Component Project, whether for the actual implementation or for implementation of Tests and Test Cases. Whatever the case, the Data stored here should be either captured directly, or referenced in such a way that data returned from the reference (URL or similar) is always reproducible.

### External Track (cp-meta)

In the entirely likely event that a Component Project does not fit into the confines of a digital information repository such as Git or GitHub, a *Meta* Component Project stores and tracks participation, progress, discussion, defects, and so on within the Agile for Volunteers and GitHub scheme with explicit and continuously-maintained reference(s) to external elements, pieces, parts, and so on, this is a Meta Component Project tracking an External Component Project

### Testing/QA/QC (cp-test)

While each Component Project should be internally and atomically testable (eg TDD method), there may be other *Test* scenarios (Functional, Integration, Stress, Failure, etc) that may be developed and maintained externally for testing of deployed systems with interaction and various forms of potential failure.

### Co-Creation (cp-cc)

Involvement of *Stakeholders* and *Customers* and *Users* in the Development process is valuable and important, and should be planned and accounted for as a Component of the Initiative. *Co-Creation* will ideally lead to *Planning* discussion and iteration (captured in the Initiative *Overview*) or specific *Implementation* issues or concerns (captured in one or more relevant Component Projects)

### Release (cp-rel)

With the Component Project repository scheme, a single Initiative release will likely depend on Back End, Front End, Database, UI, API, and others more or less from the various Component Projects (not to mention implementation language variants), thus the *Release* Component Project is a monorepo making use of Submodule, Subtree, or Subrepo (or similar) features to enable a continuous integration and delivery/deployment process, or an individual, to pull a complete Release of an Initiative in automated and reproducible fashion, tracking specific Release Versions, Tags, Milestones, etc.

### Development (cp-dev)

See *Release*, in this case a monorepo intended to gather related Component Projects in their respective current states for remote or external *Development* (where familiarity with how various component projects are intended to interoperate), system *Test* (perhaps in concert with a cp-test Component Project), or other such uses. Where a *Release* should pass tests and function as expected up to the selected point in time, a *Development* pull may be less predictable.
